// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

// Photography Core Models

model Client {
  id        String   @id @default(cuid())
  name      String   // Trade name (e.g., ATS HomeKraft)
  address   String?  // Client address
  // Main POC details (from client's side, not company)
  pocName   String?  // Main point of contact name
  pocEmail  String?  // Main POC email
  pocPhone  String?  // Main POC phone
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  entities  Entity[]
  locations Location[]
  shoots    Shoot[]

  @@index([name])
  @@index([pocEmail])
}

model Entity {
  id        String   @id @default(cuid())
  name      String   // Billing entity name
  clientId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  client    Client @relation(fields: [clientId], references: [id], onDelete: Cascade)
  shoots    Shoot[]

  @@index([name])
  @@index([clientId])
}

model ShootType {
    id          String   @id @default(cuid())
    name        String   @unique
    code        String   @unique // RE, DR, EV, VT, PC
    description String?
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    shoots      Shoot[]

    @@index([name])
    @@index([code])
}

// Location model - independent, with embedded POCs
model Location {
  id          String   @id @default(cuid())
  name        String
  address     String?
  city        String?
  state       String?
  country     String?
  coordinates String? // For storing lat/lng
  clientId    String  // Link to client
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  client      Client  @relation(fields: [clientId], references: [id], onDelete: Cascade)
  pocs        LocationPOC[] // Multiple POCs per location
  shoots      Shoot[]

  @@unique([name, clientId]) // Unique name per client
  @@index([city])
  @@index([clientId])
}

// POC linked to Location
model LocationPOC {
  id         String   @id @default(cuid())
  name       String   // POC name
  email      String?  // POC email
  phone      String   // POC phone (compulsory)
  role       String?  // POC role/title
  locationId String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  location   Location @relation(fields: [locationId], references: [id], onDelete: Cascade)

  @@index([name])
  @@index([locationId])
}

// Cluster for grouping multiple shoots (e.g., quarterly construction updates)
model Cluster {
    id              String   @id @default(cuid())
    name            String   // Cluster name (e.g., "ATS Q1 2024 Construction Updates")
    description     String?  // Description of the cluster
    clientId        String?  // Primary client for the cluster
    // Aggregate cost tracking at cluster level
    totalCost       Float?   // Total cost for the entire cluster
    createdAt       DateTime @default(now())
    updatedAt       DateTime @updatedAt

    shoots          Shoot[]  // All shoots in this cluster
    edits           Edit[]   // Edits can also be linked to clusters

    @@index([name])
    @@index([clientId])
}

model Shoot {
    id                    String    @id @default(cuid())
    shootId               String    @unique // Custom shoot ID (e.g., RE-2024-001), editable by admin
    clientId              String
    entityId              String?   // Link to specific entity
    locationId            String?
    clusterId             String?   // Link to cluster for cluster-basis workflow
    shootTypeId           String
    projectName           String?   // User-defined project name
    remarks               String?   // Free text remarks
    overallDeliverables   String?
    
    // Date/Time fields - single shoot date with reporting and wrap times
    scheduledShootDate    DateTime? // The date of the shoot
    reportingTime         String?   // Shoot start time (e.g., "09:00 AM")
    wrapUpTime            String?   // Shoot end time (e.g., "05:00 PM", default 8 hours after reporting)
    
    photographerNotes     String?
    
    // Workflow type: shift (per-shift/per-day), project (lump-sum), cluster (grouped shoots)
    workflowType          String    @default("shift") // shift, project, cluster
    
    // Cost tracking fields (for shoot only)
    shootCost             Float?    // Shoot cost (shift cost for shift-level)
    travelCost            Float?    // Travel cost (separate from shoot cost)
    shootCostStatus       String?   // paid, unpaid, onhold
    travelCostStatus      String?   // paid, unpaid, onhold
    overallCost           Float?    // For project-level shoots (no bifurcation)
    overallCostStatus     String?   // For project-level shoots
    
    // DOP and Executors
    dopId                 String?   // Director of Photography (single, main POC)
    
    status                String    @default("planned") // planned, in_progress, editing, delivered, completed, blocked, postponed, cancelled
    createdAt             DateTime  @default(now())
    updatedAt             DateTime  @updatedAt

    client                Client      @relation(fields: [clientId], references: [id], onDelete: Cascade)
    entity                Entity?     @relation(fields: [entityId], references: [id], onDelete: SetNull)
    location              Location?   @relation(fields: [locationId], references: [id], onDelete: SetNull)
    cluster               Cluster?    @relation(fields: [clusterId], references: [id], onDelete: SetNull)
    shootType             ShootType   @relation(fields: [shootTypeId], references: [id])
    dop                   User?       @relation("ShootDOP", fields: [dopId], references: [id], onDelete: SetNull)
    
    executors             ShootExecutor[] // Multiple executors who completed the shoot
    edits                 Edit[]          // One shoot can have multiple edit IDs

    @@index([shootId])
    @@index([clientId])
    @@index([entityId])
    @@index([locationId])
    @@index([shootTypeId])
    @@index([dopId])
    @@index([status])
    @@index([scheduledShootDate])
    @@index([projectName])
    @@index([clusterId])
    @@index([workflowType])
}

// Executors - actual people who completed the shoot
model ShootExecutor {
    id         String   @id @default(cuid())
    shootId    String
    userId     String
    assignedAt DateTime @default(now())

    shoot      Shoot @relation(fields: [shootId], references: [id], onDelete: Cascade)
    user       User  @relation("Executors", fields: [userId], references: [id], onDelete: Cascade)

    @@unique([shootId, userId])
    @@index([shootId])
    @@index([userId])
}

// Edit tracking - separate from shoots, per deliverable basis
model Edit {
    id                 String   @id @default(cuid())
    editId             String   @unique // Custom edit ID
    shootId            String?  // Can be linked to shoot or exist independently
    clusterId          String?  // Can be linked to cluster
    deliverables       String?  // Free text for overall deliverables
    editDeliveryDate   DateTime? // Delivery date for the edit
    editorNotes        String?
    
    // Cost tracking for edit
    editCost           Float?   // Editing cost
    editCostStatus     String?  // paid, unpaid, onhold
    
    status             String   @default("pending") // pending, in_progress, completed, delivered
    createdAt          DateTime @default(now())
    updatedAt          DateTime @updatedAt

    shoot              Shoot?   @relation(fields: [shootId], references: [id], onDelete: SetNull)
    cluster            Cluster? @relation(fields: [clusterId], references: [id], onDelete: SetNull)
    editors            EditEditor[] // Team assigned to this edit

    @@index([editId])
    @@index([shootId])
    @@index([clusterId])
    @@index([status])
    @@index([editDeliveryDate])
}

// Editors assigned to an edit
model EditEditor {
    id         String   @id @default(cuid())
    editId     String
    userId     String
    assignedAt DateTime @default(now())

    edit       Edit @relation(fields: [editId], references: [id], onDelete: Cascade)
    user       User @relation("EditEditors", fields: [userId], references: [id], onDelete: Cascade)

    @@unique([editId, userId])
    @@index([editId])
    @@index([userId])
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique // Non-compulsory
    emailVerified DateTime?
    image         String?
    password      String?   // Non-compulsory for email/password authentication
    
    // Multi-role support: user can be admin, photographer, editor, or any combination
    roles         String[]  @default(["admin"]) // ["admin"], ["photographer"], ["editor"], ["photographer", "editor"], etc.
    
    // Team member fields (for photographer/editor roles)
    phone         String?   // Compulsory (will be validated in application logic)
    specialties   String[]  @default([]) // Aligned with shoot types
    rating        Float?    @default(0) // Performance rating (0-5)
    isActive      Boolean   @default(true) // Active team member status
    
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    
    // Relations
    accounts         Account[]
    sessions         Session[]
    dopShoots        Shoot[]         @relation("ShootDOP")
    executorShoots   ShootExecutor[] @relation("Executors")
    editAssignments  EditEditor[]    @relation("EditEditors")
    
    @@index([email])
    @@index([isActive])
}

model Coupon {
    id          String   @id @default(cuid())
    code        String   @unique
    description String?
    type        String   // "percentage" or "fixed"
    value       Float    // Percentage (0-100) or fixed amount
    minAmount   Float?   // Minimum order amount
    maxUses     Int?     // Maximum number of uses (null = unlimited)
    usedCount   Int      @default(0)
    validFrom   DateTime
    validUntil  DateTime?
    isActive    Boolean  @default(true)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    @@index([code])
    @@index([isActive])
    @@index([validFrom])
    @@index([validUntil])
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}
