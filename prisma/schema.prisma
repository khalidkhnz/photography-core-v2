// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

// Photography Core Models

model Client {
  id        String   @id @default(cuid())
  name      String
  email     String?  @unique
  phone     String?
  address   String?  // Client's main address
  poc       String?  // Point of Contact name
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  locations Location[]
  shoots    Shoot[]

  @@index([name])
}

model ShootType {
    id          String   @id @default(cuid())
    name        String   @unique
    code        String   @unique // RE, DR, EV, VT, PC
    description String?
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    shoots      Shoot[]

    @@index([name])
    @@index([code])
}

model Location {
  id          String   @id @default(cuid())
  name        String
  address     String?
  city        String?
  state       String?
  country     String?
  coordinates String? // For storing lat/lng
  clientId    String? // Link to client (optional for backward compatibility)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  client      Client?  @relation(fields: [clientId], references: [id], onDelete: Cascade)
  shoots      Shoot[]

  @@unique([name, clientId]) // Unique name per client
  @@index([city])
  @@index([clientId])
}

// Cluster for grouping multiple shoots (e.g., quarterly construction updates)
model Cluster {
    id              String   @id @default(cuid())
    name            String   // Cluster name (e.g., "ATS Q1 2024 Construction Updates")
    description     String?  // Description of the cluster
    clientId        String?  // Primary client for the cluster
    // Aggregate cost tracking at cluster level
    totalCost       Float?   // Total cost for the entire cluster
    createdAt       DateTime @default(now())
    updatedAt       DateTime @updatedAt

    shoots          Shoot[]  // All shoots in this cluster

    @@index([name])
    @@index([clientId])
}

model Shoot {
    id                    String   @id @default(cuid())
    shootId               String   @unique // Custom shoot ID (e.g., RE-2024-001), editable by admin
    clientId              String
    shootTypeId           String
    locationId            String?
    clusterId             String?  // Link to cluster for cluster-basis workflow
    projectName           String?  // User-defined project name
    remarks               String?  // Free text remarks
    editId                String?  // Per deliverable basis linked to shoot ID
    overallDeliverables   String?
    shootStartDate        DateTime?
    shootEndDate          DateTime?
    photographerNotes     String?
    editorNotes           String?
    // Workflow type: shift (per-shift/per-day), project (lump-sum), cluster (grouped shoots)
    workflowType          String   @default("shift") // shift, project, cluster
    // Cost tracking fields
    photographyCost       Float?   // Shoot cost
    travelCost            Float?   // Travel cost (separate from photography)
    editingCost           Float?   // Editing cost
    executorId            String?  // The person who completed the shoot (from selected team members)
    status                String   @default("planned") // planned, in_progress, editing, delivered, completed, blocked, postponed, cancelled
    createdAt             DateTime @default(now())
    updatedAt             DateTime @updatedAt

    client                Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
    shootType             ShootType @relation(fields: [shootTypeId], references: [id])
    location              Location? @relation(fields: [locationId], references: [id])
    cluster               Cluster? @relation(fields: [clusterId], references: [id], onDelete: SetNull)
    executor              User?    @relation("ShootExecutor", fields: [executorId], references: [id], onDelete: SetNull)
    
    teamMembers           ShootTeamMember[] // Unified team assignments (photographers & editors)

    @@index([shootId])
    @@index([clientId])
    @@index([shootTypeId])
    @@index([executorId])
    @@index([status])
    @@index([shootStartDate])
    @@index([projectName])
    @@index([clusterId])
    @@index([workflowType])
}

// Unified junction table for shoot team assignments (photographers & editors)
model ShootTeamMember {
    id             String   @id @default(cuid())
    shootId        String
    userId         String   // References User (can have photographer or editor role)
    assignmentType String   // "photographer" or "editor" - what they're doing in this shoot
    role           String?  // "Lead", "Assistant", etc. - hierarchical role
    assignedAt     DateTime @default(now())

    shoot          Shoot @relation(fields: [shootId], references: [id], onDelete: Cascade)
    user           User  @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([shootId, userId, assignmentType]) // Same user can be both photographer AND editor in one shoot
    @@index([shootId])
    @@index([userId])
    @@index([assignmentType])
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime?
    image         String?
    password      String?   // For email/password authentication
    
    // Multi-role support: user can be admin, photographer, editor, or any combination
    roles         String[]  @default(["admin"]) // ["admin"], ["photographer"], ["editor"], ["photographer", "editor"], etc.
    
    // Team member fields (for photographer/editor roles)
    phone         String?
    specialties   String[]  @default([]) // Photography, Videography, Photo Editing, Video Editing, etc.
    rating        Float?    @default(0) // Performance rating (0-5)
    isActive      Boolean   @default(true) // Active team member status
    
    createdAt     DateTime  @default(now())
    updatedAt     DateTime  @updatedAt
    
    // Relations
    accounts         Account[]
    sessions         Session[]
    shootAssignments ShootTeamMember[]
    executedShoots   Shoot[]     @relation("ShootExecutor")
    
    @@index([email])
    @@index([isActive])
}

model Coupon {
    id          String   @id @default(cuid())
    code        String   @unique
    description String?
    type        String   // "percentage" or "fixed"
    value       Float    // Percentage (0-100) or fixed amount
    minAmount   Float?   // Minimum order amount
    maxUses     Int?     // Maximum number of uses (null = unlimited)
    usedCount   Int      @default(0)
    validFrom   DateTime
    validUntil  DateTime?
    isActive    Boolean  @default(true)
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    @@index([code])
    @@index([isActive])
    @@index([validFrom])
    @@index([validUntil])
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}
